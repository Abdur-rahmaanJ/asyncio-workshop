<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>asyncio w praktyce - PyconPL 2017</title>

    <link href="res/styles/bootstrap.min.css" rel="stylesheet">
    <link href="res/styles/agate.css" rel="stylesheet">
    <style>
    pre {
        border: none;
        padding: none;
        margin: none;
        background: none;
    }
    table.table th, table.table td {
        text-align: center;
        font-family: monospace;
    }
    table.table td {
        border: 1px solid #dfdfdf;
    }
    table.table th {
        background-color: #efefef;
    }
    p.hint {
        color: #bbb;
    }
    .hint-button {
        display: inline-block;
        margin: 1em 0;
    }
    </style>
  </head>
  <body>
    <div class="container">
        <div class="panel panel-default">
            <div class="panel-heading" style="text-align: center;">
                <h1>asyncio w praktyce - PyconPL 2017, Ossa</h1>
            </div>
        </div>
        <div class="panel panel-default">
            <div class="panel-heading">Zanim zaczniesz</div>
            <div class="panel-body">
                <h3>Wymagania wstępne</h3>
                <ul>
                    <li>Python 3.5 lub 3.6
                    <li>pip
                    <li>virtualenv
                    <li>git (clone wystarczy)
                </ul>
                Upewnij się, że masz utworzony virtualenv na potrzeby warsztatu, zainstalowane wymagane biblioteki oraz pracujesz na tym środowisku.
                <pre><code class="bash">python3.6 -m venv ve
source ve/bin/activate
pip install -r requirements.pip</code></pre>
                Po zainstalowaniu wszystkiego uruchom testy (a w zasadzie ich zalążek):
                <pre><code class="bash">cd projekt
pytest tests.py</code></pre>
                Spodziewany rezultat:
                <pre><code class="python">tests.py F

=========================================== FAILURES ===========================================
______________________________ test_receives_sent_message[pyloop] ______________________________

test_client = <function test_client.<locals>.go at 0x106339400>

    async def test_receives_sent_message(test_client):
        client = await test_client(app)
        connection = await client.ws_connect('/ws?nickname=JohnDoe')

        message = 'Hello, world!'
        connection.send_str(message)
        response = await connection.receive_str()

>       assert response == message
E       AssertionError: assert 'response from a server' == 'Hello, world!'
E         - response from a server
E         + Hello, world!

tests/test_websocket.py:12: AssertionError
----------------------------------- Captured stdout teardown -----------------------------------
websocket connection closed
=================================== 1 failed in 0.07 seconds ===================================</code></pre>
                <p>Fail jedynego testu jest ok - już wkrótce sprawimy, by przechodził.</p>
                <h3>Legenda</h3>
                <div class="alert alert-success">Zadanie must-have. Bez zrealizowania nie idź dalej!</div>
                <div class="alert alert-warning">Zadanie nice-to-have. Rozszerza lekko zakres podstawowy, uwzględnia testy.</div>
                <div class="alert alert-danger">Zadanie dodatkowe, specjalnie dla koksów lub jako praca domowa.</div>
                <h3>Pomocne materiały</h3>
                <ul>
                    <li><a href="https://docs.python.org/3/library/asyncio.html">Dokumentacja asyncio</a>
                    <li><a href="http://aiohttp.readthedocs.io/en/stable/">Dokumentacja aiohttp</a>
                </ul>
            </div>
        </div>

        <div class="panel panel-default">
            <div class="panel-heading">Część pierwsza - czat ogólny</div>
            <div class="panel-body">
                <h3>Wprowadzenie</h3>
                <p>W pierwszej części zajmiemy się oprogramowaniem pokoju ogólnego - miejsca, gdzie każdy z uczestnikow czatu może się udzielać i czytać przychodzące wiadomości.</p>
                <p>Zanim zaczniemy implementację, zapoznajmy się z dostarczonymi plikami projektu.</p>
                <pre><code class="bash">Otwórz plik index.html</code></pre>
                <p>W tym pliku mamy zaimplementowaną część frontendową naszej aplikacji. Ta część jest dostarczona przez organizatora warsztatów, nie powinno być potrzeby nic tutaj zmieniać. Zawiera podstawą logikę obsługi WebSocketu, odbieranie i wysyłanie wiadomości.</p>
                <pre><code class="bash">Otwórz plik app.py</code></pre>
                <p>Tutaj znajduje się główny kod aplikacji. W trakcie warsztatów szczególnie będzie nas interesować funkcja <em>websocket_handler</em>, w której będzie następować implementacja większości potrzebnych nam rzeczy:
                <pre><code class="python">async def websocket_handler(request):

    ws = web.WebSocketResponse()
    await ws.prepare(request)   # przełączenie połączenia w tryb websocket

    # ws.close() - closes connection
    # ws.send_str(str) - sends a str

    async for msg in ws:
        # msg.type - type of a message. See WSMsgType
        # msg.data - data received

        if msg.type == WSMsgType.TEXT:  # jeżeli odebrano tekstową wiadomość
            # msg.data - data received
            await ws.send_str('response from a server')     # odeślij ciąg znaków 'response from a server'
        elif msg.type == WSMsgType.ERROR:  # jeżeli zanotowano błąd
            print('ws connection closed with exception %s' % ws.exception())  # wypisz treść błędu i zakończ

    return ws</code></pre>
                <p>Pozostała część kodu w pliku <em>app.py</em> zawiera kod inicjalizujący aiohttp i wystawiający kilka dodatkowych endpointów:</p>
                <pre><code class="python">async def index(request):
    return web.FileResponse('./index.html')


async def css(request):
    return web.FileResponse('./static/style.css')


async def reconnecting_websocket(request):
    return web.FileResponse('./static/reconnecting-websocket.min.js')


async def members(request):
    return web.Response(text='[]')


app = web.Application()
app.router.add_get('/', index)
app.router.add_get('/members', members)
app.router.add_get('/style.css', css)
app.router.add_get('/reconnecting-websocket.min.js', reconnecting_websocket)
app.router.add_get('/ws', websocket_handler)

if __name__ == '__main__':
    web.run_app(app, port=8080)
</code></pre>
                <p>Aby wystartować aplikację, wykonaj polecenie:</p>
                <pre><code class="bash">python app.py</code></pre>
                <p>Gdy otworzysz w przeglądarce <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080/</a> powinieneś zobaczyć stronę chatu.</p>
                <div class="alert alert-danger" role="alert"><b>Uwaga</b>: Aplikacja domyślnie działa na porcie 8080. Jeżeli z jakiegoś powodu nie chcesz na nim jej uruchamiać, możesz go zmienić na końcu plików <b>app.py</b> i <b>index.html</b>.</div>
                <p>Ostatni z plików dostarczonych z projektem to <em>tests.py</em></p>
                <pre><code class="python">from .app import app


async def test_receives_sent_message(test_client):  # test_client jest 'magicznie' przekazywanym parametrem. pytest o to dba
    client = await test_client(app)  # tworzymy klienta testowego
    connection = await client.ws_connect('/ws')  # nawiązujemy połączenie websocket

    message = 'Hello, world!'
    await connection.send_str(message)  # wysyłamy tekstem 'Hello, world!'
    response = await connection.receive_str()  # odbieramy tekst jako odpowiedź

    assert response == message  # sprawdzamy, czy serwer odpowiedział nam oczekiwanym tekstem</code></pre>
                <p>Jak łatwo zauważyć z testu, oczekujemy że serwer będzie nam zawsze odsyłał wysyłaną przez nas wiadomość. To nasze pierwsze zadanie.</p>
                <div class="alert alert-success" role="alert">
                    <h4>Zadanie 1.1 - obsługa przychodzącej wiadomości</h4>
                    <p>Spraw, by pierwszy test przechodził (uruchamianie <em>pytest tests.py</em>)</p>
                    <p>Spodziewany rezultat w przeglądarce jest taki, że po odebraniu wiadomości wyświetli się ona na liście konwersacji.</p>
                </div>
                <div class="alert alert-warning" role="alert">
                    <b>Uwaga</b>: ten warsztat zakłada rozwijanie chatu pod ścisłą kontrolą testów, jednak jeżeli mają Cię poważnie spowalniać i spowodować, że mniej wyniesiesz z ćwiczeń możesz pomijać ich pisanie. Mimo wszystko gorąco polecam trzymać się TDD :)
                </div>
                <p>Po zrealizowaniu zadania 1.1 wydawać by się mogło, że mamy działającą aplikację i już z powodzeniem możemy na niej rozmawiać z innymi ludźmi. Tak się jednak nie dzieje, bowiem gdy otworzymy stronę chatu w drugim oknie przeglądarki (<b>otworzymy kolejną sesję websocket</b>), to nie zobaczymy wiadomości wysyłanych przez innych uczestników!</p>
                <p>Powód jest oczywisty - nasz <em>websocket_handler</em> działa tylko w ramach jednego połączenia. Musimy gdzieś przechować listę obecnych klientów połączonych z adresem <em>/ws</em> i wysyłać wiadomość do wszystkich 'obecnych'.</p>
                <div class="alert alert-warning" role="alert">
                    <h4>Zadanie 1.2a - wiadomości do pozostałych uczestników</h4>
                    <p>Najpierw napisz test, który wykaże defekt opisany w poprzednim akapicie.</p>
                    <a class="btn btn-default hint-button" role="button" data-toggle="collapse" href="#hint-1" aria-expanded="false" aria-controls="hint-1">Podpowiedź: scenariusz testu</a>
                    <div class="collapse" id="hint-1">
                      <div class="well">
                        <ul>
                            <li>Połączenie A jest nawiązane
                            <li>Połączenie B jest nawiązane
                            <li>Połączenie A wysyła wiadomość
                            <li>Połączenie B może ją odebrać
                        </ul>
                      </div>
                    </div>
                </div>
                <p><b>Pro tip</b>: Przy komunikacji ze światem zewnętrznym nie wolno nikomu ufać! Dlatego zawsze stosuj <em>timeout'y</em> przy odbieraniu odpowiedzi! Przykład:</p>
                <pre><code class="python">response = await connection.receive_str(timeout=1)  # po sekundzie rzuca TimeoutError</code></pre>
                <div class="alert alert-success" role="alert">
                    <h4>Zadanie 1.2b - wiadomości do pozostałych uczestników</h4>
                    <p>Zaimplementuj wysyłanie wiadomości do wszystkich podłączonych uczestników czatu.</p>
                    <a class="btn btn-default hint-button" role="button" data-toggle="collapse" href="#hint-2" aria-expanded="false" aria-controls="hint-2">Podpowiedź: gdzie przechować uczestników chatu?</a>
                    <div class="collapse" id="hint-2">
                      <div class="well">
                        Najprościej jest utworzyć listę globalnie w module:
                        <pre><code class="python">connections = []
async def websocket_handler(request):

    ws = web.WebSocketResponse()
    await ws.prepare(request)
    connections.append(ws)</code></pre>
                        Jest to jednak bardzo mało eleganckie rozwiązanie, dodatkowo odradzane w aiohttp.
                        Zamiast tego polecaną metodą jest wykorzystanie kontekstu aplikacji aiohttp:
                        <pre><code class="python"># For storing global-like variables, feel free to save them in an Application instance:
app['chat_members'] = []

# and get it back in the web-handler:
async def websocket_handler(request):
    chat_members = request.app['chat_members']
</code></pre>
                      </div>
                    </div>
                </div>
                <p>Być może podczas implementacji poprzedniego zadania doszło do sytuacji, że podczas próby wysłania wiadomości do uczestnika chatu nie był on już połączony przy pomocy websocketa. W takiej sytuacji dostaniemy wyjątek. Pora więc nie tylko oznaczyć uczestnikow czatu jako obecnych, ale też zadbać o to by byli usuwani z listy po rozłączeniu. Nie możemy też zapominać o obsłudze błędów przy wysyłaniu wiadomości!</p>
                <div class="alert alert-success" role="alert">
                    <h4>Zadanie 1.3 - obsługa rozłączeń z chatu</h4>
                    <p>Zadbaj o to, by uczestnicy byli usuwani po rozłączeniu z websocketem, tak aby nie podejmowano prób wysłania im wiadomości, które z oczywistych powodów nie mogą się udać. Potrzebna będzie też obsługa wyjątków przy nieudanej próbie wysyłki wiadomości.</p>
                </div>
                <p>Obsługa obecności "wewnątrz" aplikacji to jedno, ale pozostaje jeszcze kwestia przyjaznej dla uczestników prezentacji listy obecności. Obecnie w <em>index.html</em> zaimplementowane jest cykliczne zapytanie, które co 3 sekundy wysyła zapytanie na backend pod url <em>GET /members</em> i oczekuje w odpowiedzi prostej listy z ksywkami obecnych na czacie osób. Dane w odpowiedzi mają być w następującym formacie:</p>
                <pre><code class="json">[
    'kswyka1',
    'kswyka2',
    'kswyka_n'
]</code></pre>
                <p>Ksywka naszego uczestnika jest wysyłana w pierwotnym requeście na url /ws jako parametr 'nickname'</p>
                <pre><code class="python">request.GET['nickname']</code></pre>
                <div class="alert alert-success" role="alert">
                    <h4>Zadanie 1.4 - zaimplementuj endpoint dla listy obecności</h4>
                    <p>Aby zrealizować to zadanie trzeba będzie wzbogacić strukturę danych w której trzymasz podłączonych uczestników o ich ksywki wysyłane w nagłówku <em>X-Nickname</em></p>
                </div>
                <p>Na tym etapie mamy już całkiem nieźle funkcjonującą aplikację do chatowania. Jest jeszcze jedna rzecz, którą warto byłoby mieć - trzymanie historii dla przyszłych uczestników, którzy dołączą do pokoju. Powiedzmy, że nie interesują nas wszystkie wiadomości wysłane od początku działania aplikacji. Powinny wystarczyć nam wiadomości z powiedzmy ostatnich 10 minut od dołączenia.</p>
                <div class="alert alert-success" role="alert">
                    <h4>Zadanie 1.5a - prezentuj nowym uczestnikom chatu archiwalne wiadomości sprzed maksymalnie 10 minut</h4>
                    <p>Proste trzymanie wiadomości w pamięci aplikacji powinno wystarczyć. Jeżeli brak Ci pomysłu na zwracanie wiadomości tylko sprzed 10 minut - możesz pominąć to wymaganie i zawsze zwracać całą historię.</p>
                </div>
                <div class="alert alert-warning" role="alert">
                    <h4>Zadanie 1.5b - przechowuj archiwalne wiadomość w pliku</h4>
                    <p>Zwykle trzymanie danych w pamięci to kiepski pomysł. Zamiast tego spróbuj zapisać je na dysku. Koniecznie ochroń się przed jednoczesnymi modyfikacjami tego samego pliku - <a href="https://docs.python.org/3/library/asyncio-sync.html#asyncio.Lock">Lock</a>. <br>Do samej obsługi plików bez blokowania całej pętli zdarzeń można podejść na dwa sposoby: <br>a) wykorzystać executora (patrz prezentacja lub <a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_in_executor">dokumentacja</a>) <br>b) przy pomocy zewnętrznej biblioteki <a href="https://github.com/Tinche/aiofiles">aiofiles</a>. </p>
                </div>

                <div class="alert alert-danger" role="alert">
                    <h4>Zadanie 1.5c - nie blokuj całego czatu przez jednego wolnego klienta</h4>
                    <p>Najprawdopodobniej zadanie 1.2 zostało zaimplementowane w sposób, który wysyła nowe wiadomości po kolei do obecnych na czacie uczestników. Spróbuj przerobić kod tak, by wysyłać wiadomości do wszystkich uczestników 'jednocześnie', tak by jeden powolny klient nienadążający z odbieraniem danych nie blokował całej aplikacji chatowej.</p>
                    <a class="btn btn-default hint-button" role="button" data-toggle="collapse" href="#hint-3" aria-expanded="false" aria-controls="hint-3">Podpowiedź: jak podejść do problemu?</a>
                    <div class="collapse" id="hint-3">
                      <div class="well">
                        Samo wywołanie <em>ws.send_str('response from a server')</em> poprzedzone słówkiem kluczowym await 'blokuje' miejsce, w którym się znajdujemy. Natomiast wartością wyrażenia <em>ws.send_str('response from a server')</em> jest obiekt, na który można <em>poczekać</em>. W asyncio są funkcje, dzięki którym można czekać na wiele takich obiektów jednocześnie:
                        <pre><code class="python">await asyncio.gather(awaitable1, awaitable2, ...)
await asyncio.wait(awaitable1, awaitable2, ...)
</code></pre>
Warto wiedzieć, czym różnią się te dwie metody przed zaimplementowaniem któregoś z tych rozwiązań.
                      </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="panel panel-default">
            <div class="panel-heading">Część druga - pokoje</div>
            <div class="panel-body">
                <p></p>
                <h3>Zadanie 2.1</h3>
                <p>Testujemy klasę <code>AuthService</code> z jedną metodą publiczną <code>authenticate</code> - przyjmuje login i hasło. Ma zwracać <code>True</code> jezeli dane sa poprawne, w przeciwnym wypadku <code>False</code>. Metoda ma też skutek uboczny - korzysta z <code>user_logged_in</code> obiektu klasy DummyEventBroker do rozesłania zdarzenia o pomyślnej autoryzacji.</p>
                <p>Uruchomienie pliku 1-deps.py powinno poskutkować FAILem:</p>
                <pre><code class="python">Es
======================================================================
ERROR: test_auth_service_existing_user (__main__.CoupledTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "1-deps.py", line 54, in test_auth_service_existing_user
    result = service.authenticate('jacek', 'dubilas')
  File "1-deps.py", line 30, in authenticate
    user = self._adapter.fetch_user_for_credentials(login, password)
  File "1-deps.py", line 19, in fetch_user_for_credentials
    return session.query(User).filter_by(login=login, password=password).one()
  File "/Users/spb/Projects/pycon/workshop-python/ve/lib/python3.5/site-packages/sqlalchemy/orm/query.py", line 2479, in one
    raise orm_exc.NoResultFound("No row was found for one()")
sqlalchemy.orm.exc.NoResultFound: No row was found for one()

----------------------------------------------------------------------
Ran 2 tests in 0.005s

FAILED (errors=1, skipped=1)</code></pre>
                <p>Powodem jest to, że <code>AuthService</code> korzysta z <code>AuthDBAdapter</code>, który z kolei odwołuje się do bazy danych, gdzie oczywiście nie ma użytkownika, którego dane wpisaliśmy w teście. Nie jest to więc test jednostkowy - do działania wymaga bazy danych.</p>
                <div class="alert alert-info"><b>Polecenie</b>: zastąp instancję <code>AuthDBAdapter</code> wykorzystywaną do inicjalizacji obiektu klasy <code>AuthService</code> korzystając z biblioteki mock. Spraw, by test przechodził dla podanych danych autoryzacyjnych.</div>
                <p>Przykładowe użycie biblioteki mock:</p>
                <pre><code class="python">&gt;&gt;&gt; import mock
&gt;&gt;&gt; m = mock.Mock(method=mock.Mock(return_value=5))
&gt;&gt;&gt; m.method()
5</code></pre>
                <h3>Zadanie 2.2</h3>
                <p>Mocki potrafią zastąpić wiele kłopotliwych zależności, ale potrafią też przysporzyć problemów, o czym autor przekonał się osobiście. Mniej oczywiste jest bowiem, że domyślnie:</p>
                <pre><code class="python">&gt;&gt;&gt; import mock
&gt;&gt;&gt; m = mock.Mock(method=mock.Mock(return_value=5))
&gt;&gt;&gt; m.method()
5
&gt;&gt;&gt; m.surprise()
&lt;Mock name='mock.surprise()' id='4422837024'&gt;
&gt;&gt;&gt; bool(m.surprise()) # ?</code></pre>
                <p>Wywołanie nieokreślonej jawnie metody na obiekcie klasy mock zwraca kolejnego mocka, który umieszczony np w instrukcji <code>if</code> będzie ewaluował do <code>True</code>.</p>
                <div class="alert alert-info"><b>Polecenie</b>: w metodzie <code>authenticate</code> klasy <code>AuthService</code> zmień wywołanie metody <code>fetch_user_for_credentials</code> na inną, nieobecną w klasie <code>AuthDBAdapter</code>. Sprawdź, jak to wpłynie na wynik testu.</div>
                <h3>Zadanie 2.3</h3>
                <p>Istnieje niezerowe prawdopodobieństwo, że zastepowanie zależności obiektami klasy <code>Mock</code> doprowadzi do pułapki false-positive (pozytywny wynik testu mimo występowania błędu). Mając wykonane poprzednie zadanie, pozbądź się tego problemu. Sprawdź w dokumentacji unittest.mock (podlinkowana w sekcji "Więcej" tej części szkolenia) czym są <code>spec</code> i <code>autospec</code>.</p>
                <div class="alert alert-info"><b>Polecenie</b>: użyj <code>spec</code> podczas tworzenia obiektu Mock, by zapobiec pułapce false-positive.</div>
                <h3>Zadanie 2.4</h3>
                <p>Wszystko pięknie, ale... osoby znające SOLID pewnie rwią włosy z głowy patrząc na <code>AuthService</code>, która ma więcej niż jedną odpowiedzialność - waliduje dane wejściowe w sposób kompletnie nie związany z samym mechanizmem uwierzytelniania. Dochodzi dylemat - czy testować metodę prywatną?</p>
                <div class="alert alert-info"><b>Polecenie</b>: napisz test(y) dla klasy walidującej zestaw danych używanych do uwierzytelniania - (login, hasło). Wydziel metodę _validate do tej klasy. Spraw, by testy przeszły.</div>
                <b>Więcej</b>:<ul>
                    <li><a href="https://docs.python.org/3/library/unittest.mock.html">https://docs.python.org/3/library/unittest.mock.html</a></li>
                    <li><a href="http://engineeringblog.yelp.com/2015/02/assert_called_once-threat-or-menace.html">http://engineeringblog.yelp.com/2015/02/assert_called_once-threat-or-menace.html</a></li>
                </ul>
            </div>
        </div>
        <div class="panel panel-default">
            <div class="panel-heading">Część trzecia - krok w stronę testów integracyjnych, silny związek aplikacji z DB</div>
            <div class="panel-body">
                <pre><code class="bash">Przejdź do katalogu 2-deps.
Otwórz plik 2-deps.py</code></pre>
                <p>W prawdziwym świecie częściej mamy do czynienia z aplikacjami, które są bardzo mocno związane z jakimś systemem persystencji danych - najczęściej relacyjną bazą danych, do tego interakcję z nią prowadzimy za pomocą ORMa. Tego typu silne związki są przesłanką do tego, by napisać test korzystający z bazy danych - przynajmniej dopóki nie zrefaktoryzujemy danego komponentu aplikacji.</p>
                <p>Nie będą to już oczywiście testy jednostkowe. Spróbujmy jednak się do nich zbliżyć poprzez parę zabiegów. Po pierwsze, potrzebne dane w bazie tworzymy na wstępie, w metodzie setUp.</p>
                <div class="alert alert-warning">Istotną sprawą jest ochrona przed potencjalnymi śmieciami - czyszczenie danych przeprowadzamy zarówno przed, jak i po każdym teście.</div>
                <h3>Zadanie 3.1</h3>
                <p>Tym razem wszystko jest już przygotowane, Twoim zadaniem jest zaimplementować testowaną funkcję.</p>
                <div class="alert alert-info"><b>Polecenie</b>: Zaimplementuj <code>copy_roles</code> tak, by przechodził test przygotowany w 2-deps.py.</div>
            </div>
        </div>

        <div class="panel panel-default">
            <div class="panel-heading">Część czwarta - przedstawienie przykładowej aplikacji</div>
            <div class="panel-body">
                <pre><code class="bash">Przejdź do katalogu 3-app</code></pre>
                <p>Do końca szkolenia będziemy się zajmować testami wokół przykładowej aplikacji. Jest to usługa z RESTowym interfejsem do rezerwacji pokojów hotelowych, która udostępnia dwa zasoby:</p><ul>
                    <li>wolne pokoje</li>
                    <li>rezerwacje</li>
                </ul>
                <p>Jeden pokój może mieć wiele rezerwacji, ale tylko jedną nieanulowaną w tym czasie. Utworzenie nowej Rezerwacji wiąże się z zajęciem Pokoju - znika z listy wolnych. Flow korzystania z usługi:</p>
                <pre><code>GET /free_rooms  # ( 1 )
POST /free_rooms  # ( 2 )</code></pre>              <ol>
                <li>pobranie listy wolnych pokoi, wybór ID jednego z nich</li>
                <li>zgłoszenie nowej rezerwacji składającej się z ID pokoju rezerwowanego pokoju, dat przybycia, wyjazdu oraz imiona i nazwiska rezerwującego</li>
            </ol>
            <p>Stworzony zasób Rezerwacji można później usunąć korzystając z metody DELETE. Powoduje ona tylko ustawienie znacznika czasu na polu timestamp <code>cancelled_at</code>. Pozostaje przywiązana do danego pokoju, ale już nie blokuje jego ponownej rezerwacji.</p>
            <p>Punkt wejścia znajduje się w pliku app.py. Całość działa w oparciu o Flaska i SQLAlchemy korzystającego z bazy SQLite in memory. Posiada kilka zestawów testów. Kontrolnie, odpal je wszystkie po kolei, będąc w katalogu 3-app:</p>
            <pre><code class="bash">python unit_tests.py
unit_tests.py:25: DeprecationWarning: Please use assertEqual instead.
  self.assertEquals(expected_price, self.reservation.calculate_price())
..
----------------------------------------------------------------------
Ran 2 tests in 0.004s

OK</code></pre>
            <pre><code class="bash">python integration_tests.py
.
----------------------------------------------------------------------
Ran 1 test in 0.076s
OK</code></pre>
<pre><code>python e2e_tests.py
........
----------------------------------------------------------------------
Ran 8 tests in 0.084s

OK</code></pre>
            <p>Mamy jeszcze zestaw testów akceptacyjnych napisany w behave, ale do niego przejdziemy w ostatniej części szkolenia.</p>
            <h3>Zadanie 4.1</h3>
            <div class="alert-info alert"><b>Polecenie</b>: Zapoznaj się z przepływem sterowania (prześledź kolejne wywołania w kodzie) przy obsłudze żądania POST /reservations obsługiwanej przez funkcję <code>make_reservation</code>. Zwróć uwagę na warstwy aplikacji, szczególnie na dwa różne rodzaje walidacji i różnice co do otoczenia, w jakim się znajdują.</div>
            <b>Więcej</b>:<ul>
                <li><a href="http://flask.pocoo.org/docs/0.10/testing/">http://flask.pocoo.org/docs/0.10/testing/</a></li>
            </ul>
            </div>
        </div>

        <div class="panel panel-default">
            <div class="panel-heading">Część piąta - testy integracyjne ze światem zewnętrznym</div>
            <div class="panel-body">
                <p>Otwórz pliki</p>
                <pre><code class="bash">3-app/charge.py
3-app/integration_tests.py</code></pre>
                <p>Mamy tu do czynienia z kawałkiem interfejsu do zewnętrznej usługi - naliczania opłat na podstawie numeru karty kredytowej, kodu bezpieczeństwa i dedykowanego dla naszego klienta <i>access_tokenu</i>.</p>
                <p>Docelowo powinien zostać zintegrowany z przykładową aplikacją jako część procesu potwierdzania rezerwacji poprzez dokonanie opłaty za pokój. Po utworzeniu Rezerwacji powinno dojść do wysłania kolejnego żądania metodą PUT z danymi do karty płatniczej. Na razie skupmy się na samej klasie <code>ChargeExternalService</code> stanowiącej nasz punkt styku ze światem zewnętrznym.</p>
                <div class="alert-warning alert">Proszę nie wysyłać danych prawdziwych kart płatniczych :)</div>
                <h3>Zadanie 5.1</h3>
                <div class="alert alert-info"><b>Polecenie</b>: Napisz test z użyciem prawidłowego tokena. Ponieważ nie chcesz podawać prawdziwych danych, wykorzystaj te istniejące...lub zajrzyj do pliku <code>extra/cardno.py</code>, gdzie znajduje się kod źródłowy usługi uruchomionej w chmurze. Pamiętaj by sprawdzić wynik funkcji - test bez asercji to grzech główny testowania.</div>
                <p class="hint">Testy integracyjne ze światem zewnętrznym potrafią trwać niemiłosiernie długo, a poza tym mogą powodować różne niepożądane skutki uboczne, jak opróżnienie konta bankowego lub uruchomienie wyrzutni pocisków balistycznych, jeżeli się z takową integrujesz. Warto wówczas rozważyć napisanie fake'owej mini-aplikacji, która będzie odpowiadać zgodnie ze specyfikacją docelowej usługi.</p>
            </div>
        </div>


        <div class="panel panel-default">
            <div class="panel-heading">Część szósta - Behaviour Driven Development</div>
            <div class="panel-body">
            <p>Przejdź do katalogu</p>
            <pre><code class="bash">3-app</code></pre><p>Otwórz plik</p>
                <pre><code class="bash">features/making_reservations.feature</code></pre>
                <p>Przyjrzyjmy się notacji zapisu testów BDD:</p>
                <pre><code class="gherkin">Feature: One can make a reservation of a room specifying arrival and departure date

 Background: Assuming following system state
    Given There are rooms
     | id | floor | number | price_per_day |
     |  8 |     2 |    200 |           100 |
     |  9 |     2 |    201 |           100 |

Scenario: One can make a reservation of free rooms
 Given Room with ID "8" is available
  When "John Doe" reserves room "8" from "2015-10-10" to "2015-10-16"
  Then Reservation for room "8" is made
   And Room with ID "8" is not available

Scenario: One can cancel reservation a week before start
 Given Today is "2015-10-02"
  When "John Doe" reserves room "9" from "2015-10-10" to "2015-10-16"
   And One cancells reservation
  Then Room with ID "9" is available</code></pre>
  <p>To, co od razu rzuca się w oczy to notacja i język użyty w definicjach kroków. Ma on być zrozumiały także dla ludzi nieprogramujących, którzy spisują specyfikacje lub historyjki użytkownika. W tym zestawie mamy dwa scenariusze rezerwacji - ścieżkę podstawową całej funkcjonalności rezerwacji, tj zajęcie wolnego pokoju, a także ścieżkę podstawową anulowania rezerwacji.</p>
  <p>W tym konkretnym kontekście użycia będziemy mówić o testowaniu akceptacyjnym aplikacji - czy robi to, czego oczekuje od niej biznes. Nasze testy będą zaimplementowane na warstwie serwisów/CommandHandlerów (<code>3-app/domain/services.py</code>). Pomijamy w ten sposób Flaska i całe HTTP, a skupiamy się na odseparowanej maksymalnie od webowego frameworka logice biznesowej.</p>
  <p>W innych przypadkach aplikacji webowych, które korzystają z interfejsu użytkownika w postaci klasycznej strony w HTML&amp;JavaScript, testy BDD są implementowane jako testy End2End - przy pomocy Selenium lub innego webdrivera zestaw testów wchodzi w interakcję ze stroną sprawdzając, czy cała aplikacja 'zachowuje' się tak, jak jest to oczekiwane. Zdaniem autora takie podejście może się sprawdzić tylko przy prostych aplikacjach. W przypadku gdy ma się do czynienia z czymś więcej niż zaawansowaną przeglądarką do bazy danych z ładnym interfejsem, większy sens ma rozbicie monolitu na osobne aplikacje frontendową/backendową i testowanie na poziomie CommandHandlerów, udsotępniających operacje domenowe.</p>
  <p>Kolejny krok - to odseparowanie całkowicie testów akceptacyjnych od mechanizmów persystencji, jak bazy danych. To zagadnienie jednak zdecydowania wykracza poza ramy tego warsztatu. Szukając odpowiedzi na pytanie "jak" warto zainteresować się DDD i przykładowo projektem <a href="https://github.com/isolate-org">Isolate</a> (Uwaga, PHP).</p>
  <p>Będąc bardziej realistycznym, testy akceptacyjne w notacji BDD w tym projekcie wykorzystują bazę danych.</p>
  <p>Porzucając polityczne dyskusje, odpalmy zestaw testów poprzez wydanie polecenia</p><pre><code>behave</code></pre><p> w katalogu <code>3-app/</code>. Naszym oczom ukazuje się wynik:</p><pre><code>Feature: One can make a reservation of a room specifying arrival and departure date # features/making_reservations.feature:1

  Background: Assuming following system state  # features/making_reservations.feature:3

  Scenario: One can make a reservation of free rooms                    # features/making_reservations.feature:9
    Given There are rooms                                               # features/steps/making_reservations.py:11 0.001s
      | id | floor | number | price_per_day |
      | 8  | 2     | 200    | 100           |
      | 9  | 2     | 201    | 100           |
    Given Room with ID "8" is available                                 # features/steps/making_reservations.py:18 0.003s
    When "John Doe" reserves room "8" from "2015-10-10" to "2015-10-16" # features/steps/making_reservations.py:24 0.004s
    Then Reservation for room "8" is made                               # features/steps/making_reservations.py:41 0.000s
    And Room with ID "8" is not available                               # features/steps/making_reservations.py:35 0.001s

  Scenario: One can cancel reservation a week before start              # features/making_reservations.feature:15
    Given There are rooms                                               # features/steps/making_reservations.py:11 0.001s
      | id | floor | number | price_per_day |
      | 8  | 2     | 200    | 100           |
      | 9  | 2     | 201    | 100           |
    Given Today is "2015-10-02"                                         # features/steps/making_reservations.py:46 -1294419.045s
    When "John Doe" reserves room "9" from "2015-10-10" to "2015-10-16" # features/steps/making_reservations.py:24 0.000s
    And One cancells reservation                                        # features/steps/making_reservations.py:52 0.000s
    Then Room with ID "9" is available                                  # features/steps/making_reservations.py:56 0.000s

1 feature passed, 0 failed, 0 skipped
2 scenarios passed, 0 failed, 0 skipped
10 steps passed, 0 failed, 0 skipped, 0 undefined
Took -21573m20.965s</code></pre>
<p>Szczególnie ważne jest rozróżnienie kroków - w BDD odpowiadają one dobrze znanemu schematowi widocznemu przy testach AAA - Arrange - Act - Assert, tu odpowiednio Given, When, Then. Given - tworzy warunki początkowe. When - wyzwala jakieś zdarzenie, akcję. Then - sprawdza rezultat.</p>
    <h3>Zadanie 6.1</h3>
    <p>BDD poza wartościami typu <a href="http://martinfowler.com/bliki/UbiquitousLanguage.html">UbiquitousLanguage</a> niesie ze sobą także fantastyczną z punktu widzenia programisty reużywalność kodu oraz łatwość tworzenia kolejnych scenariuszy.</p>
    <p>Wracając na ziemię do rezerwacji pokojów - zwykle nie pozwala się odwołać rezerwacji w ostatniej chwili. Zaimplementujmy to.</p>
    <div class="alert alert-info"><b>Polecenie</b>: Korzystając z przykładowych scenariuszy, dopisz kolejny, który uniemożliwi anulowanie rezerwacji 3 dni przed terminem przyjazdu.</div>
  <p><b>Więcej</b>:</p><ul>
      <li><a hef="http://pythonhosted.org/behave/">http://pythonhosted.org/behave/</a></li>
      <li><a href="http://dannorth.net/whats-in-a-story/">http://dannorth.net/whats-in-a-story/</a></li>
  </ul>
            </div>

        </div>

        <div class="panel panel-default">
            <div class="panel-heading">Część siódma - meta</div>
            <div class="panel-body">
                <p>Kontakt do autora: <a href="https://twitter.com/EnforcerPL">@EnforcerPL</a></p>
                <p>Wykorzystane projekty do stworzenia szkolenia:</p>
                <ul>
                    <li><a href="http://highlightjs.org/">highlightjs</a></li>
                    <li><a href="http://getbootstrap.com/">bootstrap 3</a></li>
                    <li><a href="http://revealjs.com/">reveal.js</a></li>
                </ul>
            </div>
        </div>
    </div>
    <script src="res/jquery-3.2.1.min.js"></script>
    <script src="res/bootstrap.min.js"></script>
    <script src="res/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
